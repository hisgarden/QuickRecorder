# Timer Fix - Recording Timer Not Counting

## Problem

**Issue:** Timer in status bar shows "00:00" and doesn't count up during recording

**Screenshot Reference:** Timer stuck at "00:00" in status bar

## Root Cause

The issue was a **race condition** in `RecordingStateManager.startRecording()`.

### The Race Condition

1. `RecordingExecutor.startRecording()` (line 40) calls:
   ```swift
   RecordingStateManager.shared.startRecording()
   ```

2. `RecordingStateManager.startRecording()` used **async dispatch**:
   ```swift
   func startRecording() {
       stateQueue.async { [weak self] in  // ❌ Returns immediately!
           guard let self = self else { return }
           
           self._startTime = Date()  // This happens LATER
           // ... other initialization
       }
   }
   ```

3. The `async` dispatch returns immediately **before** `_startTime` is set

4. When the timer fires (StatusBar.swift line 139):
   ```swift
   recordingLength = SCContext.getRecordingLength()
   ```

5. Which calls `RecordingStateManager.getRecordingLength()` (line 916-936):
   ```swift
   let time = stateQueue.sync {
       if _isPaused {
           return _timePassed
       } else if let startTime = _startTime {  // ❌ Still nil!
           return Date.now.timeIntervalSince(startTime)
       } else {
           return 0.0  // Returns 0 = "00:00"
       }
   }
   ```

6. Since `_startTime` is still `nil`, it returns `0.0`, resulting in "00:00"

### Timing Diagram

```
Time →
─────────────────────────────────────────────────────────────
RecordingExecutor.startRecording() called
   │
   ├─→ RecordingStateManager.startRecording() called
   │      │
   │      ├─→ stateQueue.async { ... } queued
   │      │
   │      └─→ RETURNS IMMEDIATELY ✅
   │
   ├─→ Continue with stream setup...
   │
   ├─→ Timer fires: getRecordingLength()
   │      │
   │      └─→ _startTime is nil ❌ → returns 0.0 → "00:00"
   │
   └─→ Async block executes (TOO LATE!)
          │
          └─→ _startTime = Date() ⏰
```

## Solution

Changed `startRecording()` to use **sync dispatch** to ensure `_startTime` is set **immediately** before the method returns.

### The Fix

**File:** `QuickRecorder/Core/RecordingStateManager.swift`

**Before (Buggy):**
```swift
func startRecording() {
    stateQueue.async { [weak self] in  // ❌ Async - race condition
        guard let self = self else { return }
        
        self._startTime = Date()
        self._timePassed = 0
        // ...
    }
}
```

**After (Fixed):**
```swift
func startRecording() {
    stateQueue.sync {  // ✅ Sync - immediate execution
        _startTime = Date()
        _timePassed = 0
        _isPaused = false
        _isResume = false
        _isSkipFrame = false
        _autoStop = 0
        _saveFrame = false
        _lastPTS = nil
        _timeOffset = CMTime(value: 0, timescale: 0)
        
        // Initialize audio engine if not already done
        if _audioEngine == nil {
            _audioEngine = AVAudioEngine()
        }
        
        notifyStateChange()
    }
}
```

### Why This Works

1. `stateQueue.sync` **blocks** until the closure completes
2. `_startTime = Date()` is executed **before** `startRecording()` returns
3. When the timer fires, `_startTime` is **already set** and valid
4. Timer correctly calculates: `Date.now.timeIntervalSince(startTime)`
5. Timer displays correct elapsed time ✅

## Changes Made

**File:** `QuickRecorder/Core/RecordingStateManager.swift`
- **Lines 314-335:** Changed from `async` to `sync` dispatch
- **Removed:** `[weak self]` capture (not needed in sync block on same queue)
- **Added:** Documentation note about why sync is used

## Why Sync is Safe Here

**Q:** Won't this cause a deadlock since we're already on the main thread?

**A:** No, because:
1. `startRecording()` is called from **async context** in `RecordingExecutor`
2. The `stateQueue` is a **different queue** from the main queue
3. We're not recursively calling into `stateQueue` (no nested dispatch)
4. This is the **entry point** for setting recording state

**Q:** Why was it async before?

**A:** Likely an over-optimization to avoid blocking. However:
- The work inside is **trivial** (just setting properties)
- The **correctness** of having `startTime` set immediately is more important
- The block executes in microseconds, not blocking anything meaningful

## Testing

To verify the fix:

1. **Build the app:**
   ```bash
   xcodebuild -project QuickRecorder.xcodeproj -scheme QuickRecorder build
   ```

2. **Start a recording**

3. **Check the timer** in the status bar

**Expected Result:**
- Timer should start at "00:00"
- Timer should immediately begin counting: "00:01", "00:02", etc.
- Timer should update every 0.5 seconds (per Timer.publish interval)

## Related Code

### Timer Update Logic (StatusBar.swift:138-142)

```swift
.onReceive(Timer.publish(every: 0.5, on: .main, in: .common).autoconnect()) { t in
    recordingLength = SCContext.getRecordingLength()
    let timePassed = Date.now.timeIntervalSince(SCContext.startTime ?? t)
    let autoStopValue = RecordingStateManager.shared.autoStop
    if autoStopValue != 0 && timePassed / 60 >= CGFloat(autoStopValue) { 
        SCContext.stopRecording() 
    }
    // ...
}
```

### Time Calculation Logic (RecordingStateManager.swift:916-936)

```swift
func getRecordingLength() -> String {
    let formatter = DateComponentsFormatter()
    formatter.allowedUnits = [.minute, .second]
    formatter.zeroFormattingBehavior = .pad
    formatter.unitsStyle = .positional
    
    let time = stateQueue.sync {
        if _isPaused {
            // When paused, use the stored timePassed
            return _timePassed
        } else if let startTime = _startTime {
            // When recording, calculate elapsed time from start
            return Date.now.timeIntervalSince(startTime)
        } else {
            // No start time means recording hasn't started or was reset
            return 0.0
        }
    }
    
    return formatter.string(from: time) ?? "00:00"
}
```

## Impact

- **Fixed:** Timer now starts counting immediately when recording starts
- **No Performance Impact:** Sync dispatch for trivial property setting is negligible
- **Thread Safety:** Maintained - still using serial queue protection
- **No Deadlock Risk:** Safe because this is the entry point, not a recursive call

## Prevention

### Best Practice for State Initialization

When initializing state that will be **immediately read** by other code:

**DO ✅**
```swift
func startSomething() {
    stateQueue.sync {  // Blocks until complete
        _startTime = Date()
        // Other critical initialization
    }
}
```

**DON'T ❌**
```swift
func startSomething() {
    stateQueue.async {  // Returns immediately
        _startTime = Date()  // Might not be set when read!
        // Other initialization
    }
}
```

### When to Use Async vs Sync

**Use `async`** when:
- The work is heavy and can happen later
- The caller doesn't need the result immediately
- You want to avoid blocking the caller

**Use `sync`** when:
- The work is trivial (property setting)
- The result is **immediately needed** by the caller
- Correctness > minor performance optimization

## Date

Fixed: 2025-12-27  
Status: ✅ Ready for testing  
Issue: Timer stuck at "00:00"  
Cause: Race condition in async initialization  
Solution: Use sync dispatch for immediate state setting
